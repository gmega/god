package ddproto1.debugger.managing;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.debug.core.DebugException;
import org.eclipse.debug.core.model.Breakpoint;

import com.sun.jdi.VirtualMachine;
import com.sun.jdi.event.Event;
import com.sun.jdi.request.BreakpointRequest;

import ddproto1.commons.DebuggerConstants;
import ddproto1.debugger.eventhandler.IEventManager;
import ddproto1.debugger.eventhandler.IProcessingContext;
import ddproto1.debugger.eventhandler.ProcessingContextManager;
import ddproto1.debugger.eventhandler.processors.IJDIEventProcessor;
import ddproto1.debugger.request.DeferrableBreakpointRequest;
import ddproto1.debugger.request.IDeferrableRequest;
import ddproto1.debugger.request.IResolutionListener;
import ddproto1.util.MessageHandler;
import ddproto1.util.collection.UnorderedMultiMap;
import ddproto1.util.traits.JDIEventProcessorTrait;
import ddproto1.util.traits.JDIEventProcessorTrait.JDIEventProcessorTraitImplementor;

public class JavaBreakpoint extends Breakpoint implements IResolutionListener, JDIEventProcessorTraitImplementor {

    private static final Logger logger = MessageHandler.getInstance().getLogger(JavaBreakpoint.class);
    private static final VMManagerFactory vmmf = VMManagerFactory.getInstance();
    
	private String typeName;
	private int    line;
    
    private Map <String, IJavaDebugTarget> targetsByName = new HashMap<String, IJavaDebugTarget>();
    private UnorderedMultiMap<IJavaDebugTarget, BreakpointRequest> requestsByTarget = new 
        UnorderedMultiMap<IJavaDebugTarget, BreakpointRequest>(HashSet.class);
    private Map <BreakpointRequest, IJavaDebugTarget> targetByRequest = 
    	new HashMap<BreakpointRequest, IJavaDebugTarget>();
    
    private JDIEventProcessorTrait jdiProcessorTrait;
    
    /** State required by the jdi processor trait. */
    boolean enabled;
    IJDIEventProcessor next;
    
    public JavaBreakpoint(){
    	jdiProcessorTrait = new JDIEventProcessorTrait(this);
    }
    	
	public String getModelIdentifier() {
		return DebuggerConstants.PLUGIN_ID;
	}
	
	public void addToTarget(IJavaDebugTarget target)
		throws DebugException
	{
        try{
            VirtualMachineManager vmm = target.getVMManager();
            DeferrableBreakpointRequest dbr = 
                new DeferrableBreakpointRequest(vmm.getName(), typeName, line);
            
            /** We want to hear of all requests generated by this deferrable request. */
            dbr.addResolutionListener(this);
            vmm.getDeferrableRequestQueue().addEagerlyResolve(dbr);
        
        }catch(Exception ex){
            logger.error("Failed to place breakpoint request.", ex);
            cancelForTarget(target);
            return;
        }
        
        registerTarget(target);
	}

    /** Called whenever a deferrable request is fulfilled */
    public void notifyResolution(IDeferrableRequest source, Object byproduct) {
        if(!(source instanceof DeferrableBreakpointRequest) ||
        		!(byproduct instanceof BreakpointRequest))
            throw new InternalError("Unexpected request type.");
                
        DeferrableBreakpointRequest dbr = (DeferrableBreakpointRequest)source;
        BreakpointRequest theRequest = (BreakpointRequest)byproduct;

        IJavaDebugTarget target = this.getTarget(dbr.getVMID());
        if(target == null) 
        	throw new InternalError("Invalid target.");
        
        VirtualMachineManager vmm = this.getTarget(dbr.getVMID()).getVMManager();
        vmm.getEventManager().addEventListener(theRequest, jdiProcessorTrait);
        
        /** Will be a voter for thread resuming under this target's processing
         * process.
         */
        vmm.getVotingManager().declareVoterFor(IEventManager.RESUME_SET);
        
        this.addRequestForTarget(theRequest, target);
    }
    
    /**
     * Specialized process - called whenever one of our event requests is
     * fulfilled (i.e. whenever one of our breakpoints is hit). 
     */
	public void specializedProcess(Event request) {
		VirtualMachineManager _target = vmmf.getVMManager(vmmf
				.getGidByVM(request.virtualMachine()));
		String targetName = _target.getName();
		IJavaDebugTarget target = this.getTarget(targetName);
		
		/** Request for cancelled breakpoint. Votes for resuming.*/
		if(target == null){
			IProcessingContext ipc = ProcessingContextManager.getInstance()
					.getProcessingContext();
			ipc.vote(IEventManager.RESUME_SET);
			return; 
		}
		
	}
    
    protected void cancelForTarget(IJavaDebugTarget target)
    	throws DebugException
    {
		List<BreakpointRequest> reqList;
    	
    	/** Removes all requests for this target. */
    	synchronized(requestsByTarget){
    		if(!requestsByTarget.containsKey(target))
    			this.throwDebugException("Invalid target.");
    		reqList = new ArrayList<BreakpointRequest>();
    		for(BreakpointRequest br : requestsByTarget.getClass(target)) reqList.add(br);
    		requestsByTarget.removeClass(target);
    		unregisterTarget(target);
    	}
    }
    
    protected void unregisterTarget(IJavaDebugTarget target){
    	targetsByName.remove(target.getVMManager().getName());
    }
    
    protected void registerTarget(IJavaDebugTarget target){
        targetsByName.put(target.getVMManager().getName(), target);
    }
    
    protected IJavaDebugTarget getTarget(String targetName){
        return targetsByName.get(targetName);
    }
    
    protected void addRequestForTarget(BreakpointRequest request, IJavaDebugTarget target){
    	synchronized(requestsByTarget){
    		requestsByTarget.add(target, request);
    	}
    }

	public void next(IJDIEventProcessor next) {
		this.next = next;
	}

	public IJDIEventProcessor next() {
		return next;
	}

	public boolean enabled() {
		return enabled;
	}

	public void enabled(boolean newValue) {
		enabled = newValue;
	}
	
	protected void throwDebugException(String exception) 
		throws DebugException {
		this.throwDebugException(exception, null);
	}
	
	protected void throwDebugException(String cause, Throwable t) 
		throws DebugException {
		throw new DebugException(
				new Status(IStatus.ERROR, DebuggerConstants.PLUGIN_ID, 
						IStatus.ERROR, cause, t));
	}

}
