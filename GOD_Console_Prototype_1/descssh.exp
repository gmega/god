#!/usr/bin/expect --
# Name: descssh
# Author: Giuliano Mega
# Version: 0.1
# Written: July 25, 2004
#
#
# Description: This script exposes an ssh session as a message
# based protocol (much like SMTP) that writes its status in stderr 
# and accepts shell messages in stdin, while routing output from 
# ssh to stdout. Good for Java/C++/Perl/god-knows-what integration 
# with the GNU OpenSSH client.
#
# Syntax: descssh [password] [host] [user] [port]

# My initial idea consisted in using the following syntax:
#    descssh [password] [ssh-options]
#
# But the command [lrange $argv 1 end] condenses all ssh options
# into a single string, rendering them unusable. There's probably
# a way around this but I couldn't find it in a 3 hour research
# on the net.
#
# Fix (21/02/2005) - "password" is sometimes "Password", so I switched
#                    the pattern to "assword". :-)
#
# 
#

set autenticated false
set prompt "(%|#|\\$) $"
catch {set prompt $env(PROMPT_REGEXP)}

if { $argc < 4 } { puts "Needs more arguments."; exit 1; }

spawn ssh -X [lindex $argv 1] -l [lindex $argv 2] -p [lindex $argv 3]

# These descssh(CODE) are to avoid possible output clashes between our
# protocol output and something else.

expect {
    (yes/no)? { 
	puts stderr "descss(100) - Must acknowledge as known host.\n";
	# URGENT-TODO: Must offer a stdin-writable prompt for this.
	send "yes\n";
	exp_continue;
    } assword: { 
	puts stderr "descssh(101) - Password sent\n";
	send "[lindex $argv 0]\n";  
	exp_continue;
    } "not known" { 
	puts stderr "descssh(201) - Unknown host\n";
	exit 2 
    } "Permission denied*\n" {
	puts stderr "descssh(202) - Permission denied\n";
	exit 3
    } -re $prompt {
	puts stderr "descssh(102) - Entering interactive mode\n";
	interact {
	    -o -re $prompt {
		puts stderr "descssh(103) - Ready for command\n";
	    }
	};
	wait ssh;
	puts stderr "descssh(104) - ssh session terminated.\n";
	exit 0;
    } 
}
