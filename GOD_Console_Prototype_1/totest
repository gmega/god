Configuration Module:

- OK. Test multiple optional children of different types for same brach key precondition.
- OK. Test cardinality constraint checking.
- Add a binary 'incarnable' attribute to the specs. Validate incarnable attribute against type attribute in the configuration file.
- Add metadata attributes that don't go to the actual incarnation. 
- Let metadata attributes be specified both in the configuration file and the deployment descriptor.
- Semi-OK. Add default values. 
- OK. Add context.

Debugger:

- The event processing chains need some serious attention. The current design is crying for a refactoring
  in the sense of making the processing chains assembly explicit. 

- When a machine dies or gets reinserted, we must clean system-wide information about its threads. This includes
  the thread UUID registry and god knows what else.
  
- OK. Make step overs work. 
- OK. Test the full <CORBA Client>-<Reuters Server>-<JacORB NS> cycle. 

- The thread state relies heavily in pending step requests. However, the resume/suspend
  methods clear the step requests. Investigate how that affects the illusions, especially
  from the user point of view.

- Requests must be reworked. They currently advertise preconditions that never get satisfied and thus stay
  forever into the deferrable request queue. Internally they work because they acquire loaded classes. I think
  the ideal solution would be to eliminate the return null/non-null protocol and add a callback so that the request
  can adjust their advertised preconditions. 
  
Critical:

- I hadn't taken classloader into consideration when I first built the deferrable request subsystem.
  It'll need some serious reworking to work properly when we have the same class being loaded by more
  than one classloader.
  
- Must fix the VirtualMachineManager so that it can accept connect/disconnect or connect/kill 
  sequences without breaking. This could involve poking other classes. 
  
More on cleanup issues:

- Distributed Thread Manager must get rid of/verify all threads that die when a VMDeath/Disconnect
  occurs. It's possible that distributed threads get broken.

- All deferrable requests that trigger multiple event requests (and store them) must arrange
  to flush those requests when their VM dies or is disconnected. This is only an issue if we're
  going to reuse the VMM - if we're to create a new VMM for each launch/connect, than this
  is not an issue. I actually think that JDT's VMM equivalent is disposable, so this is probably
  not an issue.